"""
Sistema completo de monitoreo de intensidad luminosa con sensor BH1750 (GY-30)
Para uso en huerta inteligente - medici√≥n y an√°lisis de luz solar
"""

from machine import Pin, I2C
import time
import json
import gc
import math


class BH1750LightSensor:
    """
    Sensor BH1750 completo para monitoreo de intensidad luminosa en huerta
    """

    def __init__(self, sda_pin=0, scl_pin=1, addr=0x23, enable_auto_mode=True):
        """
        Inicializa el sensor BH1750 con configuraci√≥n completa

        Args:
            sda_pin (int): Pin SDA para I2C
            scl_pin (int): Pin SCL para I2C
            addr (int): Direcci√≥n I2C del sensor (0x23 o 0x5C)
            enable_auto_mode (bool): Habilitar modo autom√°tico de resoluci√≥n
        """
        try:
            self.sda_pin = sda_pin
            self.scl_pin = scl_pin
            self.addr = addr

            # Inicializar I2C
            self.i2c = I2C(0, sda=Pin(sda_pin), scl=Pin(scl_pin), freq=100000)

            # Comandos del BH1750
            self.commands = {
                "power_on": 0x01,
                "reset": 0x07,
                "continuous_high_res": 0x10,  # 1 lx resoluci√≥n
                "continuous_high_res2": 0x11,  # 0.5 lx resoluci√≥n
                "continuous_low_res": 0x13,  # 4 lx resoluci√≥n
                "one_time_high_res": 0x20,  # Una medici√≥n 1 lx
                "one_time_high_res2": 0x21,  # Una medici√≥n 0.5 lx
                "one_time_low_res": 0x23,  # Una medici√≥n 4 lx
            }

            # Configuraci√≥n del sensor
            self.config = {
                "reading_interval_min": 1.0,  # Intervalo m√≠nimo entre lecturas
                "max_retry_attempts": 3,  # Intentos m√°ximos por lectura
                "error_threshold": 0.15,  # 15% de errores m√°ximo aceptable
                "enable_auto_mode": enable_auto_mode,
                "auto_mode_thresholds": {  # Umbrales para cambio autom√°tico de modo
                    "low_to_high": 1000,  # lux - cambiar a alta resoluci√≥n
                    "high_to_low": 50000,  # lux - cambiar a baja resoluci√≥n
                },
                "measurement_delay": {  # Tiempos de espera por modo (ms)
                    "high_res": 180,
                    "high_res2": 180,
                    "low_res": 24,
                },
            }

            # Estado actual del sensor
            self.current_mode = "continuous_high_res"
            self.last_measurement_time = 0

            # Estad√≠sticas de funcionamiento
            self.stats = {
                "total_readings": 0,
                "successful_readings": 0,
                "failed_readings": 0,
                "mode_switches": 0,
                "uptime_start": time.time(),
                "last_error": None,
            }

            # Verificar conexi√≥n e inicializar
            if self.initialize_sensor():
                print(f"üí° BH1750 inicializado correctamente")
                print(
                    f"üìç I2C: SDA=GPIO{sda_pin}, SCL=GPIO{scl_pin}, Addr=0x{addr:02X}"
                )
                print(
                    f"‚öôÔ∏è  Modo autom√°tico: {'HABILITADO' if enable_auto_mode else 'DESHABILITADO'}"
                )
            else:
                raise Exception("Fallo en inicializaci√≥n del sensor")

        except Exception as e:
            print(f"‚ùå Error inicializando BH1750: {e}")
            raise

    def initialize_sensor(self):
        """
        Inicializa el sensor con la secuencia correcta

        Returns:
            bool: True si la inicializaci√≥n fue exitosa
        """
        try:
            # Verificar presencia en bus I2C
            devices = self.i2c.scan()
            if self.addr not in devices:
                print(f"‚ùå Sensor no encontrado en direcci√≥n 0x{self.addr:02X}")
                print(f"üí° Dispositivos I2C encontrados: {[hex(d) for d in devices]}")
                return False

            # Secuencia de inicializaci√≥n
            self.i2c.writeto(self.addr, bytes([self.commands["power_on"]]))
            time.sleep_ms(10)

            self.i2c.writeto(self.addr, bytes([self.commands["reset"]]))
            time.sleep_ms(10)

            # Configurar modo inicial
            self.set_measurement_mode(self.current_mode)

            return True

        except Exception as e:
            print(f"‚ùå Error en inicializaci√≥n: {e}")
            return False

    def set_measurement_mode(self, mode):
        """
        Configura el modo de medici√≥n del sensor

        Args:
            mode (str): Modo de medici√≥n

        Returns:
            bool: True si el cambio fue exitoso
        """
        try:
            if mode not in self.commands:
                print(f"‚ùå Modo inv√°lido: {mode}")
                return False

            # Enviar comando de modo
            cmd = self.commands[mode]
            self.i2c.writeto(self.addr, bytes([cmd]))

            # Esperar tiempo apropiado seg√∫n el modo
            if "high_res" in mode:
                time.sleep_ms(self.config["measurement_delay"]["high_res"])
            elif "low_res" in mode:
                time.sleep_ms(self.config["measurement_delay"]["low_res"])

            old_mode = self.current_mode
            self.current_mode = mode

            if old_mode != mode:
                self.stats["mode_switches"] += 1

            return True

        except Exception as e:
            print(f"‚ùå Error cambiando modo: {e}")
            return False

    def read_raw_light(self):
        """
        Lee los valores crudos del sensor con reintentos

        Returns:
            dict: Resultado de la lectura cruda
        """
        self.stats["total_readings"] += 1

        # Verificar intervalo m√≠nimo
        current_time = time.time()
        if (current_time - self.last_measurement_time) < self.config[
            "reading_interval_min"
        ]:
            time.sleep(self.config["reading_interval_min"])

        # Intentar lectura con reintentos
        for attempt in range(self.config["max_retry_attempts"]):
            try:
                gc.collect()  # Limpiar memoria

                # Leer 2 bytes del sensor
                data = self.i2c.readfrom(self.addr, 2)

                # Convertir datos a valor crudo y lux
                raw_value = (data[0] << 8) | data[1]
                lux_value = raw_value / 1.2  # F√≥rmula est√°ndar BH1750

                # Validar rango f√≠sico del sensor (0-65535 lux aproximadamente)
                if 0 <= lux_value <= 100000:  # Rango extendido para casos extremos
                    self.stats["successful_readings"] += 1
                    self.last_measurement_time = current_time

                    return {
                        "success": True,
                        "lux_raw": lux_value,
                        "raw_value": raw_value,
                        "mode": self.current_mode,
                        "attempt": attempt + 1,
                        "timestamp": current_time,
                        "error": None,
                    }
                else:
                    raise ValueError(f"Valor fuera de rango: {lux_value} lux")

            except OSError as e:
                error_msg = f"Error comunicaci√≥n I2C (intento {attempt + 1}): {e}"
                if attempt == self.config["max_retry_attempts"] - 1:
                    break
                time.sleep(0.2)

            except Exception as e:
                error_msg = f"Error general (intento {attempt + 1}): {e}"
                if attempt == self.config["max_retry_attempts"] - 1:
                    break
                time.sleep(0.2)

        # Si llegamos aqu√≠, todos los intentos fallaron
        self.stats["failed_readings"] += 1
        self.stats["last_error"] = error_msg

        return {
            "success": False,
            "lux_raw": None,
            "raw_value": None,
            "mode": self.current_mode,
            "attempt": self.config["max_retry_attempts"],
            "timestamp": current_time,
            "error": error_msg,
        }

    def get_optimized_reading(self):
        """
        Obtiene lectura optimizada con modo autom√°tico si est√° habilitado

        Returns:
            dict: Lectura optimizada con an√°lisis de luz
        """
        raw_reading = self.read_raw_light()

        if not raw_reading["success"]:
            return {
                "success": False,
                "error": raw_reading["error"],
                "timestamp": raw_reading["timestamp"],
            }

        lux = raw_reading["lux_raw"]

        # Modo autom√°tico: ajustar resoluci√≥n seg√∫n intensidad
        if self.config["enable_auto_mode"]:
            optimal_mode = self.determine_optimal_mode(lux)
            if optimal_mode != self.current_mode:
                if self.set_measurement_mode(optimal_mode):
                    # Tomar nueva lectura con el modo optimizado
                    time.sleep(0.5)  # Peque√±a pausa para estabilizaci√≥n
                    raw_reading = self.read_raw_light()
                    if raw_reading["success"]:
                        lux = raw_reading["lux_raw"]

        # Clasificar tipo de luz
        light_classification = self.classify_light_intensity(lux)

        # Evaluar condiciones para plantas
        plant_analysis = self.analyze_plant_light_conditions(lux)

        # Calcular m√©tricas adicionales
        light_metrics = self.calculate_light_metrics(lux)

        return {
            "success": True,
            "timestamp": raw_reading["timestamp"],
            "lux": round(lux, 1),
            "raw_value": raw_reading["raw_value"],
            "classification": light_classification,
            "plant_analysis": plant_analysis,
            "metrics": light_metrics,
            "sensor_info": {
                "mode_used": raw_reading["mode"],
                "attempt_used": raw_reading["attempt"],
                "auto_mode_enabled": self.config["enable_auto_mode"],
            },
        }

    def determine_optimal_mode(self, lux):
        """
        Determina el modo √≥ptimo seg√∫n la intensidad de luz

        Args:
            lux (float): Intensidad luminosa actual

        Returns:
            str: Modo √≥ptimo recomendado
        """
        thresholds = self.config["auto_mode_thresholds"]

        if lux < 10:
            # Muy baja luz - usar m√°xima resoluci√≥n
            return "continuous_high_res2"
        elif lux < thresholds["low_to_high"]:
            # Luz baja a media - usar alta resoluci√≥n
            return "continuous_high_res"
        elif lux < thresholds["high_to_low"]:
            # Luz media a alta - mantener alta resoluci√≥n
            return "continuous_high_res"
        else:
            # Luz muy alta - usar baja resoluci√≥n para evitar saturaci√≥n
            return "continuous_low_res"

    def classify_light_intensity(self, lux):
        """
        Clasifica la intensidad de luz en categor√≠as descriptivas

        Args:
            lux (float): Intensidad luminosa en lux

        Returns:
            dict: Clasificaci√≥n de la luz
        """
        classifications = [
            (0, 1, "OSCURIDAD_TOTAL", "Noche sin luna", "üåë"),
            (1, 10, "MUY_OSCURO", "Noche con luna o interior muy tenue", "üåí"),
            (10, 50, "OSCURO", "Interior con luz tenue", "üåì"),
            (50, 200, "INTERIOR_NORMAL", "Habitaci√≥n bien iluminada", "üè†"),
            (200, 500, "INTERIOR_BRILLANTE", "Oficina o cocina", "üè¢"),
            (500, 1000, "TRANSICI√ìN", "Cerca de ventana o entrada", "üö™"),
            (1000, 5000, "EXTERIOR_SOMBRA", "Sombra en d√≠a nublado", "‚òÅÔ∏è"),
            (5000, 10000, "EXTERIOR_NUBLADO", "D√≠a nublado", "üå§Ô∏è"),
            (10000, 25000, "EXTERIOR_PARCIAL", "D√≠a parcialmente soleado", "‚õÖ"),
            (25000, 50000, "EXTERIOR_SOLEADO", "D√≠a soleado", "‚òÄÔ∏è"),
            (50000, 100000, "SOL_DIRECTO", "Sol directo", "üåû"),
            (100000, float("inf"), "EXTREMO", "Luz artificial intensa o reflejo", "üîÜ"),
        ]

        for min_lux, max_lux, category, description, emoji in classifications:
            if min_lux <= lux < max_lux:
                return {
                    "category": category,
                    "description": description,
                    "emoji": emoji,
                    "range": f"{min_lux}-{max_lux if max_lux != float('inf') else '‚àû'} lux",
                }

        return {
            "category": "UNKNOWN",
            "description": "Valor fuera de rangos conocidos",
            "emoji": "‚ùì",
            "range": "N/A",
        }

    def analyze_plant_light_conditions(self, lux):
        """
        Analiza las condiciones de luz para el crecimiento de plantas

        Args:
            lux (float): Intensidad luminosa en lux

        Returns:
            dict: An√°lisis de condiciones para plantas
        """
        analysis = {
            "suitability": "UNKNOWN",
            "growth_stage_recommendations": [],
            "plant_type_recommendations": [],
            "action_needed": [],
            "photoperiod_analysis": {},
            "energy_level": "UNKNOWN",
        }

        # Evaluar niveles de luz para fotos√≠ntesis
        if lux < 100:
            analysis["suitability"] = "INSUFICIENTE"
            analysis["energy_level"] = "MUY_BAJO"
            analysis["action_needed"].append("üí° Agregar iluminaci√≥n artificial")
            analysis["plant_type_recommendations"].append(
                "Solo plantas tolerantes a sombra extrema"
            )
        elif lux < 500:
            analysis["suitability"] = "MINIMA"
            analysis["energy_level"] = "BAJO"
            analysis["action_needed"].append("üí° Considerar luz suplementaria")
            analysis["plant_type_recommendations"].extend(
                ["Plantas de sombra", "Helechos", "Algunas hierbas"]
            )
        elif lux < 1000:
            analysis["suitability"] = "LIMITADA"
            analysis["energy_level"] = "BAJO_MEDIO"
            analysis["plant_type_recommendations"].extend(
                ["Lechugas", "Espinacas", "Plantas de hoja"]
            )
            analysis["growth_stage_recommendations"].append("Germinaci√≥n y pl√°ntulas")
        elif lux < 5000:
            analysis["suitability"] = "MODERADA"
            analysis["energy_level"] = "MEDIO"
            analysis["plant_type_recommendations"].extend(
                ["Hierbas arom√°ticas", "Vegetales de hoja", "Plantas de interior"]
            )
            analysis["growth_stage_recommendations"].append(
                "Crecimiento vegetativo lento"
            )
        elif lux < 15000:
            analysis["suitability"] = "BUENA"
            analysis["energy_level"] = "MEDIO_ALTO"
            analysis["plant_type_recommendations"].extend(
                ["Mayor√≠a de vegetales", "Hierbas", "Plantas ornamentales"]
            )
            analysis["growth_stage_recommendations"].extend(
                ["Crecimiento vegetativo", "Desarrollo de hojas"]
            )
        elif lux < 30000:
            analysis["suitability"] = "EXCELENTE"
            analysis["energy_level"] = "ALTO"
            analysis["plant_type_recommendations"].extend(
                ["Tomates", "Pimientos", "Plantas fruct√≠feras"]
            )
            analysis["growth_stage_recommendations"].extend(
                ["Floraci√≥n", "Fructificaci√≥n"]
            )
        elif lux < 60000:
            analysis["suitability"] = "OPTIMA"
            analysis["energy_level"] = "MUY_ALTO"
            analysis["plant_type_recommendations"].extend(
                ["Plantas de sol pleno", "Cultivos de temporada"]
            )
            analysis["growth_stage_recommendations"].append(
                "M√°ximo rendimiento fotosint√©tico"
            )
        else:
            analysis["suitability"] = "EXCESIVA"
            analysis["energy_level"] = "EXTREMO"
            analysis["action_needed"].extend(
                ["‚òÇÔ∏è Proporcionar sombra", "üíß Aumentar riego"]
            )
            analysis["plant_type_recommendations"].append(
                "Solo plantas muy resistentes al sol"
            )

        # An√°lisis de fotoperiodo (necesita historial para ser preciso)
        if lux > 1000:
            analysis["photoperiod_analysis"] = {
                "daylight_detected": True,
                "suitable_for_flowering": lux > 10000,
                "light_stress_risk": lux > 80000,
            }
        else:
            analysis["photoperiod_analysis"] = {
                "daylight_detected": False,
                "night_period": True,
                "artificial_light_needed": lux < 100,
            }

        return analysis

    def calculate_light_metrics(self, lux):
        """
        Calcula m√©tricas adicionales de luz

        Args:
            lux (float): Intensidad luminosa en lux

        Returns:
            dict: M√©tricas calculadas
        """
        metrics = {}

        # Conversi√≥n a otras unidades
        metrics["footcandles"] = lux * 0.0929  # Conversi√≥n aproximada
        metrics["watts_per_m2"] = lux * 0.0079  # Conversi√≥n aproximada para luz solar

        # Estimaci√≥n de eficiencia fotosint√©tica
        if lux <= 0:
            metrics["photosynthetic_efficiency"] = 0
        elif lux < 1000:
            metrics["photosynthetic_efficiency"] = (lux / 1000) * 20  # 0-20%
        elif lux < 30000:
            metrics["photosynthetic_efficiency"] = (
                20 + ((lux - 1000) / 29000) * 60
            )  # 20-80%
        else:
            metrics["photosynthetic_efficiency"] = min(
                95, 80 + ((lux - 30000) / 20000) * 15
            )  # 80-95%

        # Categor√≠a de actividad fotosint√©tica
        if metrics["photosynthetic_efficiency"] < 10:
            metrics["photosynthetic_category"] = "INACTIVA"
        elif metrics["photosynthetic_efficiency"] < 30:
            metrics["photosynthetic_category"] = "BAJA"
        elif metrics["photosynthetic_efficiency"] < 60:
            metrics["photosynthetic_category"] = "MODERADA"
        elif metrics["photosynthetic_efficiency"] < 80:
            metrics["photosynthetic_category"] = "ALTA"
        else:
            metrics["photosynthetic_category"] = "√ìPTIMA"

        return metrics

    def get_light_status(self):
        """
        Obtiene estado completo de iluminaci√≥n con an√°lisis

        Returns:
            dict: Estado completo de la luz
        """
        reading = self.get_optimized_reading()

        if not reading["success"]:
            return {
                "status": "ERROR",
                "error": reading["error"],
                "timestamp": reading["timestamp"],
            }

        # Calcular estad√≠sticas de funcionamiento
        success_rate = (
            self.stats["successful_readings"] / max(1, self.stats["total_readings"])
        ) * 100
        uptime = time.time() - self.stats["uptime_start"]

        return {
            "status": "SUCCESS",
            "timestamp": reading["timestamp"],
            "light_data": {
                "intensity_lux": reading["lux"],
                "classification": reading["classification"],
                "plant_analysis": reading["plant_analysis"],
                "metrics": reading["metrics"],
            },
            "sensor_health": {
                "success_rate": round(success_rate, 1),
                "total_readings": self.stats["total_readings"],
                "mode_switches": self.stats["mode_switches"],
                "uptime_hours": round(uptime / 3600, 1),
                "current_mode": self.current_mode,
                "status": (
                    "HEALTHY"
                    if success_rate >= 90
                    else "DEGRADED" if success_rate >= 70 else "CRITICAL"
                ),
            },
            "raw_data": {
                "raw_value": reading["raw_value"],
                "mode": reading["sensor_info"]["mode_used"],
            },
        }

    def monitor_light_cycle(self, duration_hours=24, interval_minutes=15):
        """
        Monitoreo del ciclo de luz durante un per√≠odo extenso

        Args:
            duration_hours (int): Duraci√≥n del monitoreo en horas
            interval_minutes (int): Intervalo entre mediciones en minutos
        """
        print(f"\n‚òÄÔ∏è MONITOREO DE CICLO DE LUZ - {duration_hours} horas")
        print(
            f"üìä Intervalo: {interval_minutes} min | Modo: {'AUTO' if self.config['enable_auto_mode'] else 'MANUAL'}"
        )
        print("\n‚è∞ Hora\t\tüí° Lux\t\tüå± Condici√≥n\t\tüìä Fotos√≠ntesis")
        print("-" * 75)

        start_time = time.time()
        end_time = start_time + (duration_hours * 3600)
        interval_seconds = interval_minutes * 60

        light_history = []
        max_lux = 0
        min_lux = float("inf")

        try:
            while time.time() < end_time:
                current_time = time.time()
                elapsed_hours = (current_time - start_time) / 3600

                # Formatear hora actual
                time_tuple = time.localtime(current_time)
                time_str = f"{time_tuple[3]:02d}:{time_tuple[4]:02d}"

                status = self.get_light_status()

                if status["status"] == "SUCCESS":
                    light = status["light_data"]
                    lux = light["intensity_lux"]
                    classification = light["classification"]["category"]
                    plant_condition = light["plant_analysis"]["suitability"]
                    photosynthesis = light["metrics"]["photosynthetic_efficiency"]

                    # Actualizar extremos
                    max_lux = max(max_lux, lux)
                    if lux > 0:  # Ignorar 0 para el m√≠nimo
                        min_lux = min(min_lux, lux)

                    # Mostrar l√≠nea de datos
                    print(
                        f"{time_str}\t\t{lux:8.1f}\t{plant_condition:12s}\t{photosynthesis:5.1f}%"
                    )

                    # Guardar para an√°lisis
                    light_history.append(
                        {
                            "hour": elapsed_hours,
                            "time_str": time_str,
                            "lux": lux,
                            "classification": classification,
                            "plant_analysis": plant_condition,
                            "photosynthesis": photosynthesis,
                        }
                    )

                    # Alertas especiales
                    if lux > 80000:
                        print(f"      ‚ö†Ô∏è  Luz extrema detectada - riesgo de estr√©s")
                    elif lux < 100 and 6 <= time_tuple[3] <= 18:  # Horas de d√≠a
                        print(f"      ‚ö†Ô∏è  Luz insuficiente durante el d√≠a")

                else:
                    print(f"{time_str}\t\t‚ùå ERROR: {status['error'][:30]}...")

                time.sleep(interval_seconds)

        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Monitoreo detenido por usuario")

        # Generar an√°lisis del ciclo
        self.analyze_light_cycle(light_history, max_lux, min_lux)

    def analyze_light_cycle(self, light_history, max_lux, min_lux):
        """
        Analiza el ciclo de luz registrado

        Args:
            light_history (list): Historial de mediciones
            max_lux (float): Intensidad m√°xima registrada
            min_lux (float): Intensidad m√≠nima registrada
        """
        if not light_history:
            print("\n‚ùå No hay datos para analizar")
            return

        # Estad√≠sticas b√°sicas
        lux_values = [reading["lux"] for reading in light_history]
        avg_lux = sum(lux_values) / len(lux_values)

        # Detectar per√≠odo de d√≠a y noche
        day_readings = [r for r in light_history if r["lux"] > 1000]
        night_readings = [r for r in light_history if r["lux"] <= 100]

        # Calcular horas de luz √∫til para plantas
        useful_light_hours = len([r for r in light_history if r["lux"] > 5000])
        optimal_light_hours = len(
            [r for r in light_history if 15000 <= r["lux"] <= 60000]
        )

        print(f"\nüìà AN√ÅLISIS DEL CICLO DE LUZ:")
        print(f"üìä Total de mediciones: {len(light_history)}")
        print(f"‚òÄÔ∏è Intensidad promedio: {avg_lux:.1f} lux")
        print(f"üîÜ Pico m√°ximo: {max_lux:.1f} lux")
        print(f"üåë M√≠nimo nocturno: {min_lux:.1f} lux")

        print(f"\nüåû AN√ÅLISIS DE FOTOPERIODO:")
        print(f"üåÖ Horas con luz diurna: {len(day_readings) * (15/60):.1f} horas")
        print(f"üåÉ Horas nocturnas: {len(night_readings) * (15/60):.1f} horas")
        print(
            f"üå± Horas de luz √∫til para plantas: {useful_light_hours * (15/60):.1f} horas"
        )
        print(f"‚≠ê Horas de luz √≥ptima: {optimal_light_hours * (15/60):.1f} horas")

        # Recomendaciones
        print(f"\nüí° RECOMENDACIONES:")

        if useful_light_hours < 8:  # Menos de 2 horas de luz √∫til
            print("   ‚Ä¢ ‚ö†Ô∏è  Per√≠odo de luz insuficiente para la mayor√≠a de plantas")
            print("   ‚Ä¢ üí° Considerar iluminaci√≥n artificial suplementaria")
        elif useful_light_hours < 24:  # Menos de 6 horas
            print(
                "   ‚Ä¢ üü° Luz limitada - adecuada solo para plantas tolerantes a sombra"
            )
            print("   ‚Ä¢ üåø Cultivar lechugas, espinacas o hierbas de sombra")
        else:
            print("   ‚Ä¢ ‚úÖ Per√≠odo de luz adecuado para cultivo")

        if max_lux > 80000:
            print("   ‚Ä¢ ‚òÇÔ∏è Picos de luz muy intensos - considerar sombra parcial")

        if optimal_light_hours > 16:  # M√°s de 4 horas de luz √≥ptima
            print("   ‚Ä¢ üöÄ Excelentes condiciones para plantas de sol pleno")
            print("   ‚Ä¢ üçÖ Ideal para tomates, pimientos y plantas fruct√≠feras")

    def greenhouse_light_controller(self):
        """
        Sistema de control autom√°tico de iluminaci√≥n para invernadero
        """
        print("\nüè† CONTROLADOR AUTOM√ÅTICO DE ILUMINACI√ìN")
        print("=" * 50)

        status = self.get_light_status()

        if status["status"] != "SUCCESS":
            print(f"‚ùå Error del sensor: {status['error']}")
            return

        light = status["light_data"]
        lux = light["intensity_lux"]
        plant_analysis = light["plant_analysis"]

        print(f"üí° Intensidad actual: {lux:.1f} lux")
        print(f"üå± Condici√≥n para plantas: {plant_analysis['suitability']}")
        print(f"üìä Clasificaci√≥n: {light['classification']['description']}")

        # Decisiones de control autom√°tico
        actions = []

        # Control de iluminaci√≥n artificial
        if lux < 500:
            actions.append("üí° ACTIVAR luces LED de crecimiento (espectro completo)")
            actions.append("‚è∞ PROGRAMAR temporizador para fotoperiodo")
        elif lux < 1000:
            actions.append("üí° ACTIVAR luces suplementarias (bajo consumo)")
        elif lux > 80000:
            actions.append("‚òÇÔ∏è DESPLEGAR pantalla de sombra")
            actions.append("üå¨Ô∏è ACTIVAR ventilaci√≥n extra")

        # Control de sombreado
        if 60000 <= lux <= 80000:
            actions.append("‚òÇÔ∏è PREPARAR sombra parcial (50%)")
        elif lux > 100000:
            actions.append("üö® SOMBRA URGENTE - Riesgo de da√±o por luz")

        # Recomendaciones de cultivo
        if plant_analysis["suitability"] in ["EXCELENTE", "OPTIMA"]:
            actions.append("üå± CONDICIONES IDEALES - Maximizar plantaci√≥n")
        elif plant_analysis["suitability"] == "INSUFICIENTE":
            actions.append("üö´ SUSPENDER siembra hasta mejorar iluminaci√≥n")

        # Mostrar acciones
        if actions:
            print(f"\nüéØ ACCIONES RECOMENDADAS:")
            for action in actions:
                print(f"   ‚Ä¢ {action}")
        else:
            print(f"\n‚úÖ CONDICIONES √ìPTIMAS - No se requieren acciones")

        # Mostrar recomendaciones espec√≠ficas de plantas
        if plant_analysis["plant_type_recommendations"]:
            print(f"\nüåø PLANTAS RECOMENDADAS PARA ESTAS CONDICIONES:")
            for plant in plant_analysis["plant_type_recommendations"]:
                print(f"   ‚Ä¢ {plant}")


def daily_light_summary(sensor, readings_per_hour=4):
    """
    Genera un resumen diario de condiciones de luz

    Args:
        sensor: Instancia del sensor BH1750
        readings_per_hour: Lecturas por hora para el an√°lisis
    """
    print("\nüìä RESUMEN DIARIO DE LUZ")
    print("=" * 40)

    # Simular lecturas durante diferentes horas del d√≠a
    hours_to_test = [6, 9, 12, 15, 18, 21]  # Representativo del d√≠a
    daily_data = []

    for hour in hours_to_test:
        print(f"\nüïê Simulando hora {hour:02d}:00")
        status = sensor.get_light_status()

        if status["status"] == "SUCCESS":
            light_data = status["light_data"]
            daily_data.append(
                {
                    "hour": hour,
                    "lux": light_data["intensity_lux"],
                    "suitability": light_data["plant_analysis"]["suitability"],
                    "photosynthesis": light_data["metrics"][
                        "photosynthetic_efficiency"
                    ],
                }
            )

            print(f"   üí° {light_data['intensity_lux']:.1f} lux")
            print(f"   üå± {light_data['plant_analysis']['suitability']}")

        time.sleep(2)  # Breve pausa entre lecturas

    # An√°lisis del d√≠a
    if daily_data:
        avg_lux = sum(d["lux"] for d in daily_data) / len(daily_data)
        max_lux = max(d["lux"] for d in daily_data)

        good_hours = len([d for d in daily_data if d["lux"] > 5000])
        optimal_hours = len([d for d in daily_data if 15000 <= d["lux"] <= 60000])

        print(f"\nüìà RESUMEN DEL D√çA:")
        print(f"‚òÄÔ∏è Promedio de luz: {avg_lux:.1f} lux")
        print(f"üîÜ Pico de luz: {max_lux:.1f} lux")
        print(f"‚è∞ Horas de buena luz: {good_hours}/{len(daily_data)}")
        print(f"‚≠ê Horas de luz √≥ptima: {optimal_hours}/{len(daily_data)}")

        # Recomendaci√≥n general
        if avg_lux > 20000:
            print("üöÄ D√çA EXCELENTE para cultivo solar")
        elif avg_lux > 10000:
            print("‚úÖ BUEN D√çA para la mayor√≠a de plantas")
        elif avg_lux > 5000:
            print("üü° D√çA REGULAR - plantas tolerantes a sombra")
        else:
            print("üî¥ D√çA PROBLEM√ÅTICO - iluminaci√≥n insuficiente")


def main():
    """
    Funci√≥n principal de demostraci√≥n
    """
    try:
        # Configuraci√≥n inicial
        print("üîß CONFIGURACI√ìN DEL SENSOR BH1750:")

        sda_input = input("Pin SDA (por defecto 0): ").strip()
        sda_pin = int(sda_input) if sda_input else 0

        scl_input = input("Pin SCL (por defecto 1): ").strip()
        scl_pin = int(scl_input) if scl_input else 1

        addr_input = input("Direcci√≥n I2C hex (por defecto 0x23): ").strip()
        if addr_input.startswith("0x"):
            addr = int(addr_input, 16)
        elif addr_input:
            addr = int(addr_input)
        else:
            addr = 0x23

        auto_mode_input = input("¬øHabilitar modo autom√°tico? (s/n): ").strip().lower()
        auto_mode = auto_mode_input.startswith("s")

        # Crear sensor
        sensor = BH1750LightSensor(
            sda_pin=sda_pin, scl_pin=scl_pin, addr=addr, enable_auto_mode=auto_mode
        )

        # Men√∫ principal
        while True:
            print("\n" + "=" * 50)
            print("üí° SISTEMA DE MONITOREO DE LUZ BH1750")
            print("=" * 50)
            print("1. üìä Estado de iluminaci√≥n actual")
            print("2. üîç Monitoreo continuo corto")
            print("3. ‚òÄÔ∏è Monitoreo de ciclo de luz (24h)")
            print("4. üè† Controlador de invernadero")
            print("5. üìà Resumen diario simulado")
            print("6. üìä Lecturas simples")
            print("7. ‚öôÔ∏è  Configuraci√≥n del sensor")
            print("8. üìã Estad√≠sticas del sensor")
            print("9. üö™ Salir")

            option = input("\nSelecciona (1-9): ").strip()

            if option == "1":
                status = sensor.get_light_status()
                if status["status"] == "SUCCESS":
                    light = status["light_data"]
                    print(f"\nüí° Intensidad: {light['intensity_lux']} lux")
                    print(
                        f"üè∑Ô∏è  Clasificaci√≥n: {light['classification']['description']} {light['classification']['emoji']}"
                    )
                    print(
                        f"üå± Condiciones plantas: {light['plant_analysis']['suitability']}"
                    )
                    print(
                        f"üìä Eficiencia fotosint√©tica: {light['metrics']['photosynthetic_efficiency']:.1f}%"
                    )

                    if light["plant_analysis"]["action_needed"]:
                        print("\nüí° Acciones recomendadas:")
                        for action in light["plant_analysis"]["action_needed"]:
                            print(f"   ‚Ä¢ {action}")
                else:
                    print(f"‚ùå Error: {status['error']}")

            elif option == "2":
                duration = int(input("Duraci√≥n en minutos (10): ") or "10")
                sensor.monitor_light_cycle(
                    duration_hours=duration / 60, interval_minutes=1
                )

            elif option == "3":
                hours = int(input("Duraci√≥n en horas (24): ") or "24")
                interval = int(input("Intervalo en minutos (15): ") or "15")
                sensor.monitor_light_cycle(
                    duration_hours=hours, interval_minutes=interval
                )

            elif option == "4":
                sensor.greenhouse_light_controller()

            elif option == "5":
                daily_light_summary(sensor)

            elif option == "6":
                print("\nüìä Lecturas cada 2s (Ctrl+C para parar)")
                try:
                    while True:
                        reading = sensor.get_optimized_reading()
                        if reading["success"]:
                            print(
                                f"üí° {reading['lux']:8.1f} lux | "
                                f"{reading['classification']['emoji']} {reading['classification']['category']} | "
                                f"üå± {reading['plant_analysis']['suitability']}"
                            )
                        else:
                            print(f"‚ùå {reading['error']}")
                        time.sleep(2)
                except KeyboardInterrupt:
                    print("\n‚èπÔ∏è  Lecturas detenidas")

            elif option == "7":
                print(f"\n‚öôÔ∏è  CONFIGURACI√ìN ACTUAL:")
                print(f"üìç I2C: SDA=GPIO{sensor.sda_pin}, SCL=GPIO{sensor.scl_pin}")
                print(f"üì° Direcci√≥n: 0x{sensor.addr:02X}")
                print(
                    f"üîÑ Modo autom√°tico: {'HABILITADO' if sensor.config['enable_auto_mode'] else 'DESHABILITADO'}"
                )
                print(f"‚öôÔ∏è  Modo actual: {sensor.current_mode}")

            elif option == "8":
                stats = sensor.stats
                success_rate = (
                    stats["successful_readings"] / max(1, stats["total_readings"])
                ) * 100
                uptime = time.time() - stats["uptime_start"]

                print(f"\nüìä ESTAD√çSTICAS DEL SENSOR:")
                print(f"üìà Tasa de √©xito: {success_rate:.1f}%")
                print(f"üìä Lecturas totales: {stats['total_readings']}")
                print(f"‚öôÔ∏è  Cambios de modo: {stats['mode_switches']}")
                print(f"‚è±Ô∏è  Tiempo funcionando: {uptime/3600:.1f} horas")
                if stats["last_error"]:
                    print(f"‚ùå √öltimo error: {stats['last_error']}")

            elif option == "9":
                print("üëã ¬°Hasta luego!")
                break

            else:
                print("‚ùå Opci√≥n no v√°lida")

    except KeyboardInterrupt:
        print("\nüëã ¬°Hasta luego!")
    except Exception as e:
        print(f"‚ùå Error: {e}")


if __name__ == "__main__":
    main()
